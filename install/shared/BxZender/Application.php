<?phpclass BxZender_Application{	const CONFIG = 'bitrix';	private static $_instance = null;		protected $_options = array();		protected $_optionKeys = array();		protected $_autoloader = null;		protected $_bootstrap = null;		public function __construct($options = null)	{		require_once 'Zend/Loader/Autoloader.php';		spl_autoload_register();        $this->_autoloader = Zend_Loader_Autoloader::getInstance();        // bitrix autoloader		$this->_autoloader->pushAutoloader(array('CModule', 'RequireAutoloadClass'));		if (null !== $options)        {            if (is_string($options))            {                $options = $this->_loadConfig($options);            }            elseif ($options instanceof Zend_Config)            {                $options = $options->toArray();            }            elseif (!is_array($options))            {                throw new Exception('Invalid options provided; must be location of config file, a config object, or an array');            }            $this->setOptions($options);        }		self::$_instance = $this;	}		public function setOptions(array $options)    {        if (!empty($options['config']))        {            if (is_array($options['config']))            {                $_options = array();                foreach ($options['config'] as $tmp)                {                    $_options = $this->mergeOptions($_options, $this->_loadConfig($tmp));                }                $options = $this->mergeOptions($_options, $options);            }            else            {                $options = $this->mergeOptions($this->_loadConfig($options['config']), $options);            }        }        $this->_options = $options;        $options = array_change_key_case($options, CASE_LOWER);        $this->_optionKeys = array_keys($options);        if (!empty($options['phpsettings']))        {            $this->setPhpSettings($options['phpsettings']);        }        if (!empty($options['includepaths']))        {            $this->setIncludePaths($options['includepaths']);        }        if (!empty($options['autoloadernamespaces']))        {            $this->setAutoloaderNamespaces($options['autoloadernamespaces']);        }        if (!empty($options['bootstrap']))         {            $bootstrap = $options['bootstrap'];            if (is_string($bootstrap))            {                $this->setBootstrap($bootstrap);            }            elseif (is_array($bootstrap))            {                if (empty($bootstrap['path']))                {                    throw new Exception('No bootstrap path provided');                }                $path  = $_SERVER['DOCUMENT_ROOT'] . $bootstrap['path'];                $class = null;                if (!empty($bootstrap['class']))                {                    $class = $bootstrap['class'];                }                $this->setBootstrap($path, $class);            }            else            {                throw new Exception('Invalid bootstrap information provided');            }        }        return $this;    }		public function getOptions()    {        return $this->_options;    }		public function hasOption($key)    {        return in_array(strtolower($key), $this->_optionKeys);    }		public function getOption($key)    {        if ($this->hasOption($key))        {            $options = $this->getOptions();            $options = array_change_key_case($options, CASE_LOWER);            return $options[strtolower($key)];        }        return null;    }		public function mergeOptions(array $array1, $array2 = null)    {        if (is_array($array2))        {            foreach ($array2 as $key => $val)            {                if (is_array($array2[$key]))                {                    $array1[$key] = (array_key_exists($key, $array1) && is_array($array1[$key]))                                  ? $this->mergeOptions($array1[$key], $array2[$key])                                  : $array2[$key];                }                else                {                    $array1[$key] = $val;                }            }        }        return $array1;    }		public function setPhpSettings(array $settings, $prefix = '')    {        foreach ($settings as $key => $value)        {            $key = empty($prefix) ? $key : $prefix . $key;            if (is_scalar($value))            {                ini_set($key, $value);            }            elseif (is_array($value))            {                $this->setPhpSettings($value, $key . '.');            }        }        return $this;    }    /**     * Set include path     *     * @param  array $paths     * @return BxZender_Application     */    public function setIncludePaths(array $paths)    {        $path = implode(PATH_SEPARATOR, $paths);        set_include_path($path . PATH_SEPARATOR . get_include_path());        return $this;    }    /**     * Set autoloader namespaces     *     * @param  array $namespaces     * @return BxZender_Application     */    public function setAutoloaderNamespaces(array $namespaces)    {        $autoloader = $this->getAutoloader();        foreach ($namespaces as $namespace)        {            $autoloader->registerNamespace($namespace);        }        return $this;    }	public function setBootstrap($path, $class = null)    {        // setOptions() can potentially send a null value; specify default        // here        if (null === $class)        {            $class = 'Bootstrap';        }        if (!class_exists($class, false))        {            require_once $path;            if (!class_exists($class, false))            {                var_dump('Bootstrap class not found');                throw new Zend_Application_Exception('Bootstrap class not found');            }        }		        $this->_bootstrap = new $class($this);		        if (!$this->_bootstrap instanceof Zend_Application_Bootstrap_Bootstrapper)        {            throw new Zend_Application_Exception('Bootstrap class does not implement Zend_Application_Bootstrap_Bootstrapper');        }        return $this;    }		public function getBootstrap()    {        if (null === $this->_bootstrap)        {			$this->_bootstrap = new BxZender_Application_Bootstrap($this);        }        return $this->_bootstrap;    }		public function getEnvironment()    {        return self::CONFIG;    }		public static function bootstrap()	{		self::prepare();		self::$_instance->getBootstrap()->bootstrap(NULL);	}		public static function run()	{		self::prepare();		self::$_instance->getBootstrap()->run();	}    public static function postEpilog()    {        self::prepare();        self::$_instance->getBootstrap()->post();    }	private static function prepare()	{		if (self::$_instance === null)        {			self::$_instance = new self(BXZENDER_DEFAULT_CONFIG);		}	}		protected function _loadConfig($file)    {        $suffix = strtolower(pathinfo($file, PATHINFO_EXTENSION));        switch ($suffix) {            case 'ini':                $config = new Zend_Config_Ini($file, self::CONFIG);                break;            case 'xml':                $config = new Zend_Config_Xml($file, self::CONFIG);                break;            case 'json':                $config = new Zend_Config_Json($file, self::CONFIG);                break;            case 'yaml':                $config = new Zend_Config_Yaml($file, self::CONFIG);                break;            case 'php':            case 'inc':                $config = include $file;                if (!is_array($config))                {                    throw new Exception('Invalid configuration file provided; PHP file does not return array value');                }                return $config;                break;            default:                throw new Exception('Invalid configuration file provided; unknown config type');        }        return $config->toArray();    }}